import * as protobuf from 'protobufjs';

/**
 * Type mapping from protobuf to TypeScript
 */
export const TYPE_MAPPING: Record<string, string> = {
    double: 'number',
    float: 'number',
    int32: 'number',
    int64: 'string',
    uint32: 'number',
    uint64: 'string',
    sint32: 'number',
    sint64: 'string',
    fixed32: 'number',
    fixed64: 'string',
    sfixed32: 'number',
    sfixed64: 'string',
    bool: 'boolean',
    string: 'string',
    bytes: 'Uint8Array',
};

/**
 * Maps a protobuf type to a TypeScript type
 * @param type The protobuf type
 * @param isRepeated Whether the field is repeated
 * @returns The corresponding TypeScript type
 */
export function mapProtoTypeToTs(type: string, isRepeated = false): string {
    // Handle enum types or message types
    const mappedType = TYPE_MAPPING[type] || type;
    return isRepeated ? `${mappedType}[]` : mappedType;
}

/**
 * Gets the TypeScript interface name from a protobuf message type
 * @param messageName The protobuf message name
 * @returns The TypeScript interface name
 */
export function getInterfaceName(messageName: string): string {
    // Remove package name if present
    const parts = messageName.split('.');
    const name = parts[parts.length - 1];

    return name;
}

/**
 * Gets a TypeScript representation of a protobuf enum
 * @param enumType The protobuf enum
 * @returns TypeScript enum definition
 */
export function getEnumDefinition(enumType: protobuf.Enum): string {
    let definition = `export enum ${enumType.name} {\n`;

    Object.keys(enumType.values).forEach(key => {
        definition += `  ${key} = ${enumType.values[key]},\n`;
    });

    definition += '}\n';
    return definition;
}

/**
 * Gets a TypeScript interface representation of a protobuf message
 * @param messageType The protobuf message type
 * @returns TypeScript interface definition
 */
export function getMessageDefinition(messageType: protobuf.Type): string {
    let definition = `export interface ${messageType.name} {\n`;

    messageType.fieldsArray.forEach(field => {
        const fieldType = mapProtoTypeToTs(field.type, field.repeated);
        const isOptional = !field.required;
        definition += `  ${field.name}${isOptional ? '?' : ''}: ${fieldType};\n`;
    });

    definition += '}\n';
    return definition;
}

/**
 * Gets a TypeScript interface for a gRPC service client
 * @param serviceType The protobuf service type
 * @returns TypeScript interface definition for the client
 */
export function getServiceClientDefinition(serviceType: protobuf.Service): string {
    let definition = `export interface ${serviceType.name}Client {\n`;

    serviceType.methodsArray.forEach(method => {
        // Convert method name to camelCase
        const methodName = method.name.charAt(0).toLowerCase() + method.name.slice(1);
        const inputType = getInterfaceName(method.requestType);
        const outputType = getInterfaceName(method.responseType);

        definition += `  ${methodName}(request: ${inputType}): Observable<${outputType}>;\n`;
    });

    definition += '}\n';
    return definition;
}

/**
 * Gets a TypeScript interface for a gRPC service implementation
 * @param serviceType The protobuf service type
 * @returns TypeScript interface definition for the implementation
 */
export function getServiceImplementationDefinition(serviceType: protobuf.Service): string {
    let definition = `export interface ${serviceType.name}Interface {\n`;

    serviceType.methodsArray.forEach(method => {
        // Convert method name to camelCase
        const methodName = method.name.charAt(0).toLowerCase() + method.name.slice(1);
        const inputType = getInterfaceName(method.requestType);
        const outputType = getInterfaceName(method.responseType);

        definition += `  ${methodName}(request: ${inputType}): Observable<${outputType}>;\n`;
    });

    definition += '}\n';
    return definition;
}

/**
 * Generates TypeScript type definitions from a protobuf root
 * @param root The protobuf root
 * @returns The generated TypeScript definitions
 */
export function generateTypeDefinitions(root: protobuf.Root): string {
    let typeDefinitions = '// This file is auto-generated by nestjs-grpc\n\n';
    typeDefinitions += "import { Observable } from 'rxjs';\n\n";

    // Process all nested items
    function processNamespace(namespace: protobuf.NamespaceBase): void {
        namespace.nestedArray.forEach(nested => {
            if (nested instanceof protobuf.Type) {
                typeDefinitions += getMessageDefinition(nested) + '\n';
            } else if (nested instanceof protobuf.Service) {
                typeDefinitions += getServiceClientDefinition(nested) + '\n';
                typeDefinitions += getServiceImplementationDefinition(nested) + '\n';
            } else if (nested instanceof protobuf.Enum) {
                typeDefinitions += getEnumDefinition(nested) + '\n';
            } else if (nested instanceof protobuf.Namespace) {
                processNamespace(nested);
            }
        });
    }

    processNamespace(root);

    return typeDefinitions;
}
