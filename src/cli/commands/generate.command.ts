import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import * as chalk from 'chalk';
import * as protobuf from 'protobufjs';
import * as chokidar from 'chokidar';

interface GenerateCommandOptions {
    proto: string;
    output: string;
    watch: boolean;
    recursive?: boolean;
}

export async function generateCommand(options: GenerateCommandOptions): Promise<void> {
    try {
        // Check if proto is a directory without glob pattern
        const isDirectory =
            fs.existsSync(options.proto) && fs.statSync(options.proto).isDirectory();

        // If it's a directory and doesn't end with a glob pattern, add it
        if (isDirectory && !options.proto.endsWith('/**/*.proto')) {
            const normalizedPath = options.proto.endsWith('/')
                ? options.proto
                : `${options.proto}/`;

            options.proto = `${normalizedPath}**/*.proto`;
            console.log(chalk.blue(`Directory detected, using pattern: ${options.proto}`));
        }

        const protoFiles = glob.sync(options.proto, { ignore: 'node_modules/**' });

        if (protoFiles.length === 0) {
            console.log(chalk.yellow(`No proto files found matching pattern: ${options.proto}`));
            return;
        }

        console.log(chalk.blue(`Found ${protoFiles.length} proto file(s)`));

        // Initial generation
        for (const protoFile of protoFiles) {
            await generateTypesForFile(protoFile, options.output);
        }

        // Setup watch mode if requested
        if (options.watch) {
            console.log(chalk.blue('\nWatching for changes...'));

            const watchPatterns = isDirectory
                ? options.proto
                : protoFiles.map(file => path.dirname(file) + '/**/*.proto');

            const watcher = chokidar.watch(watchPatterns, {
                persistent: true,
                ignoreInitial: true,
                ignorePermissionErrors: true,
                ignored: 'node_modules/**',
            });

            watcher.on('add', async filePath => {
                if (filePath.endsWith('.proto')) {
                    console.log(chalk.green(`File added: ${filePath}`));
                    await generateTypesForFile(filePath, options.output);
                }
            });

            watcher.on('change', async filePath => {
                if (filePath.endsWith('.proto')) {
                    console.log(chalk.green(`File changed: ${filePath}`));
                    await generateTypesForFile(filePath, options.output);
                }
            });

            watcher.on('unlink', filePath => {
                if (filePath.endsWith('.proto')) {
                    const outputFile = getOutputPath(filePath, options.output);
                    if (fs.existsSync(outputFile)) {
                        fs.unlinkSync(outputFile);
                        console.log(chalk.yellow(`Removed generated file: ${outputFile}`));
                    }
                }
            });

            console.log(chalk.blue('Press Ctrl+C to stop watching'));
            // Keep process alive
            process.stdin.resume();
        }
    } catch (error) {
        console.error(chalk.red('Error generating types:'), error);
        process.exit(1);
    }
}

async function generateTypesForFile(protoFile: string, outputDir: string): Promise<void> {
    try {
        const outputFile = getOutputPath(protoFile, outputDir);

        // Create output directory if it doesn't exist
        const outputDirPath = path.dirname(outputFile);
        if (!fs.existsSync(outputDirPath)) {
            fs.mkdirSync(outputDirPath, { recursive: true });
        }

        // Load the proto file
        const root = await protobuf.load(protoFile);

        // Generate TypeScript interfaces
        const typeDefinitions = generateTypeDefinitions(root);

        // Write to file
        writeTypesToFile(typeDefinitions, outputFile);

        console.log(chalk.green(`Generated types for ${protoFile} â†’ ${outputFile}`));
    } catch (error) {
        console.error(chalk.red(`Error processing ${protoFile}:`), error);
    }
}

function getOutputPath(protoFile: string, outputDir: string): string {
    const baseName = path.basename(protoFile, '.proto');
    return path.join(outputDir, `${baseName}.ts`);
}

function generateTypeDefinitions(root: protobuf.Root): string {
    let typeDefinitions = '// This file is auto-generated by nestjs-grpc\n\n';
    typeDefinitions += "import { Observable } from 'rxjs';\n\n";

    // Process all nested types recursively
    typeDefinitions = processNamespace(root, '', typeDefinitions);

    return typeDefinitions;
}

function processNamespace(
    namespace: protobuf.NamespaceBase,
    prefix: string,
    output: string,
): string {
    let result = output;

    namespace.nestedArray.forEach(nested => {
        const fullName = prefix ? `${prefix}.${nested.name}` : nested.name;

        if (nested instanceof protobuf.Type) {
            result += processMessageType(nested, fullName);
        } else if (nested instanceof protobuf.Service) {
            result += processServiceType(nested, fullName);
        } else if (nested instanceof protobuf.Enum) {
            result += processEnumType(nested, fullName);
        } else if (nested instanceof protobuf.Namespace) {
            result += processNamespace(nested, fullName, '');
        }
    });

    return result;
}

function processMessageType(type: protobuf.Type, fullName: string): string {
    let definition = `export interface ${type.name} {\n`;

    type.fieldsArray.forEach(field => {
        const fieldType = mapProtoTypeToTs(field.type, field.repeated);
        const isOptional = !field.required;
        definition += `  ${field.name}${isOptional ? '?' : ''}: ${fieldType};\n`;
    });

    definition += '}\n\n';
    return definition;
}

function processServiceType(service: protobuf.Service, fullName: string): string {
    let definition = `export interface ${service.name}Client {\n`;

    service.methodsArray.forEach(method => {
        // Convert method name to camelCase
        const methodName = method.name.charAt(0).toLowerCase() + method.name.slice(1);
        const inputType = method.requestType.split('.').pop();
        const outputType = method.responseType.split('.').pop();

        definition += `  ${methodName}(request: ${inputType}): Observable<${outputType}>;\n`;
    });

    definition += '}\n\n';

    // Also generate a service interface for implementing the service
    definition += `export interface ${service.name}Interface {\n`;
    service.methodsArray.forEach(method => {
        // Convert method name to camelCase
        const methodName = method.name.charAt(0).toLowerCase() + method.name.slice(1);
        const inputType = method.requestType.split('.').pop();
        const outputType = method.responseType.split('.').pop();

        definition += `  ${methodName}(request: ${inputType}): Observable<${outputType}>;\n`;
    });
    definition += '}\n\n';

    return definition;
}

function processEnumType(enumType: protobuf.Enum, fullName: string): string {
    let definition = `export enum ${enumType.name} {\n`;

    Object.keys(enumType.values).forEach(key => {
        definition += `  ${key} = ${enumType.values[key]},\n`;
    });

    definition += '}\n\n';
    return definition;
}

function mapProtoTypeToTs(protoType: string, repeated: boolean): string {
    const typeMap: { [key: string]: string } = {
        string: 'string',
        bool: 'boolean',
        int32: 'number',
        int64: 'string',
        uint32: 'number',
        uint64: 'string',
        sint32: 'number',
        sint64: 'string',
        fixed32: 'number',
        fixed64: 'string',
        sfixed32: 'number',
        sfixed64: 'string',
        float: 'number',
        double: 'number',
        bytes: 'Uint8Array',
    };

    const mappedType = typeMap[protoType] || protoType;
    return repeated ? `${mappedType}[]` : mappedType;
}

function writeTypesToFile(content: string, outputPath: string): void {
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, content, 'utf8');
}
